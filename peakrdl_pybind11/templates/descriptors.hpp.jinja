/*
 * {{ soc_name }}_descriptors.hpp
 * Generated by PeakRDL-pybind11
 * 
 * C++ descriptor classes for SystemRDL register map
 */

#ifndef {{ soc_name.upper() }}_DESCRIPTORS_HPP
#define {{ soc_name.upper() }}_DESCRIPTORS_HPP

#include <cstdint>
#include <string>
#include <memory>
#include <functional>

namespace {{ soc_name }} {

// Forward declarations
class Master;
class RegisterBase;
class FieldBase;

/**
 * Abstract Master interface for register access
 */
class Master {
public:
    virtual ~Master() = default;
    
    /**
     * Read a value from the given address
     */
    virtual uint64_t read(uint64_t address, size_t width) = 0;
    
    /**
     * Write a value to the given address
     */
    virtual void write(uint64_t address, uint64_t value, size_t width) = 0;
};

/**
 * Base class for register fields
 */
class FieldBase {
public:
    FieldBase(const std::string& name, uint64_t offset, 
              uint8_t lsb, uint8_t width, bool readable, bool writable)
        : name_(name), offset_(offset), lsb_(lsb), 
          width_(width), readable_(readable), writable_(writable) {}
    
    virtual ~FieldBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    uint8_t lsb() const { return lsb_; }
    uint8_t msb() const { return lsb_ + width_ - 1; }
    uint8_t width() const { return width_; }
    bool is_readable() const { return readable_; }
    bool is_writable() const { return writable_; }
    
    uint64_t mask() const { 
        return ((1ULL << width_) - 1) << lsb_; 
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    uint8_t lsb_;
    uint8_t width_;
    bool readable_;
    bool writable_;
};

/**
 * Base class for registers
 */
class RegisterBase {
public:
    RegisterBase(const std::string& name, uint64_t offset, size_t width)
        : name_(name), offset_(offset), width_(width), master_(nullptr) {}
    
    virtual ~RegisterBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    size_t width() const { return width_; }
    
    void set_master(Master* master) { master_ = master; }
    
    /**
     * Read the full register value
     */
    uint64_t read() {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        return master_->read(offset_, width_);
    }
    
    /**
     * Write the full register value
     */
    void write(uint64_t value) {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        master_->write(offset_, value, width_);
    }
    
    /**
     * Read-modify-write operation with mask
     */
    void modify(uint64_t value, uint64_t mask) {
        uint64_t current = read();
        uint64_t new_value = (current & ~mask) | (value & mask);
        write(new_value);
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    size_t width_;
    Master* master_;
};

/**
 * Base class for address maps and register files
 */
class NodeBase {
public:
    NodeBase(const std::string& name, uint64_t offset)
        : name_(name), offset_(offset), master_(nullptr) {}
    
    virtual ~NodeBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    
    virtual void set_master(Master* master) { 
        master_ = master;
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    Master* master_;
};

{% for addrmap in nodes.addrmaps %}
// Forward declaration for {{ addrmap.inst_name }}
class {{ addrmap.inst_name }}_t;
{% endfor %}

{% for regfile in nodes.regfiles %}
// Forward declaration for {{ regfile.inst_name }}
class {{ regfile.inst_name }}_t;
{% endfor %}

{% for reg in nodes.regs %}
// Register: {{ reg.inst_name }}
class {{ reg.inst_name }}_t : public RegisterBase {
public:
    {{ reg.inst_name }}_t(uint64_t base_offset) 
        : RegisterBase("{{ reg.inst_name }}", base_offset + 0x{{ "%x" | format(reg.absolute_address) }}, {{ reg.size }}) {}
    
    {% for field in reg.fields() %}
    // Field: {{ field.inst_name }}
    class {{ field.inst_name }}_field : public FieldBase {
    public:
        {{ field.inst_name }}_field({{ reg.inst_name }}_t* parent)
            : FieldBase("{{ field.inst_name }}", parent->offset(), 
                       {{ field.low }}, {{ field.width }},
                       {{ 'true' if field.is_hw_readable or field.is_sw_readable else 'false' }},
                       {{ 'true' if field.is_hw_writable or field.is_sw_writable else 'false' }}),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field {{ field.inst_name }} is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field {{ field.inst_name }} is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        {{ reg.inst_name }}_t* parent_;
    };
    
    {{ field.inst_name }}_field {{ field.inst_name }}{this};
    {% endfor %}
};

{% endfor %}

// Top-level SoC class
class {{ soc_name }}_t : public NodeBase {
public:
    {{ soc_name }}_t() : NodeBase("{{ soc_name }}", 0) {
        {% for child in top_node.children() %}
        {% if child.inst_name %}
        {{ child.inst_name }}.set_offset(offset_);
        {% endif %}
        {% endfor %}
    }
    
    void attach_master(Master* master) {
        set_master(master);
        propagate_master(master);
    }
    
    void set_offset(uint64_t offset) {
        offset_ = offset;
        {% for child in top_node.children() %}
        {% if child.inst_name %}
        {{ child.inst_name }}.set_offset(offset_);
        {% endif %}
        {% endfor %}
    }
    
    void propagate_master(Master* master) {
        {% for child in top_node.children() %}
        {% if child.inst_name %}
        {{ child.inst_name }}.set_master(master);
        {% endif %}
        {% endfor %}
    }
    
    {% for child in top_node.children() %}
    {% if child.inst_name %}
    {{ child.inst_name }}_t {{ child.inst_name }}{0x{{ "%x" | format(child.absolute_address if child.absolute_address else 0) }}};
    {% endif %}
    {% endfor %}
};

} // namespace {{ soc_name }}

#endif // {{ soc_name.upper() }}_DESCRIPTORS_HPP
