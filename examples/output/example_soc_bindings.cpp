/*
 * example_soc_bindings.cpp
 * Generated by PeakRDL-pybind11
 * 
 * PyBind11 bindings for SystemRDL register map
 */

#include <pybind11/pybind11.h>
#include <pybind11/functional.h>
#include "example_soc_descriptors.hpp"

namespace py = pybind11;
using namespace example_soc;

PYBIND11_MODULE(_example_soc_native, m) {
    m.doc() = "example_soc register map generated from SystemRDL";
    
    // Master interface
    py::class_<Master>(m, "Master")
        .def("read", &Master::read, "Read from address")
        .def("write", &Master::write, "Write to address");
    
    // FieldBase
    py::class_<FieldBase>(m, "FieldBase")
        .def_property_readonly("name", &FieldBase::name)
        .def_property_readonly("offset", &FieldBase::offset)
        .def_property_readonly("lsb", &FieldBase::lsb)
        .def_property_readonly("msb", &FieldBase::msb)
        .def_property_readonly("width", &FieldBase::width)
        .def_property_readonly("is_readable", &FieldBase::is_readable)
        .def_property_readonly("is_writable", &FieldBase::is_writable)
        .def_property_readonly("mask", &FieldBase::mask);
    
    // RegisterBase
    py::class_<RegisterBase>(m, "RegisterBase")
        .def_property_readonly("name", &RegisterBase::name)
        .def_property_readonly("offset", &RegisterBase::offset)
        .def_property_readonly("width", &RegisterBase::width)
        .def("read", &RegisterBase::read, "Read register value")
        .def("write", &RegisterBase::write, "Write register value")
        .def("modify", &RegisterBase::modify, "Read-modify-write operation");
    
    // NodeBase
    py::class_<NodeBase>(m, "NodeBase")
        .def_property_readonly("name", &NodeBase::name)
        .def_property_readonly("offset", &NodeBase::offset);
    
    // Register class: control
    py::class_<control_t, RegisterBase>(m, "control_t", "<p>UART control and configuration</p>")
        .def(py::init<uint64_t>())
        .def_readonly("enable", &control_t::enable)
        .def_readonly("baudrate", &control_t::baudrate)
        .def_readonly("parity", &control_t::parity)
        ;
    
    // Field class: control.enable
    py::class_<control_t::enable_field, FieldBase>(m, "control_enable_field", "<p>Enable UART</p>")
        .def("read", &control_t::enable_field::read, "Read field value")
        .def("write", &control_t::enable_field::write, "Write field value");
    // Field class: control.baudrate
    py::class_<control_t::baudrate_field, FieldBase>(m, "control_baudrate_field", "<p>Baudrate selection (0=9600, 1=19200, 2=115200)</p>")
        .def("read", &control_t::baudrate_field::read, "Read field value")
        .def("write", &control_t::baudrate_field::write, "Write field value");
    // Field class: control.parity
    py::class_<control_t::parity_field, FieldBase>(m, "control_parity_field", "<p>Parity mode (0=none, 1=odd, 2=even)</p>")
        .def("read", &control_t::parity_field::read, "Read field value")
        .def("write", &control_t::parity_field::write, "Write field value");
    // Register class: status
    py::class_<status_t, RegisterBase>(m, "status_t", "<p>UART status flags</p>")
        .def(py::init<uint64_t>())
        .def_readonly("tx_ready", &status_t::tx_ready)
        .def_readonly("rx_ready", &status_t::rx_ready)
        .def_readonly("error", &status_t::error)
        ;
    
    // Field class: status.tx_ready
    py::class_<status_t::tx_ready_field, FieldBase>(m, "status_tx_ready_field", "<p>Transmit buffer ready</p>")
        .def("read", &status_t::tx_ready_field::read, "Read field value")
        .def("write", &status_t::tx_ready_field::write, "Write field value");
    // Field class: status.rx_ready
    py::class_<status_t::rx_ready_field, FieldBase>(m, "status_rx_ready_field", "<p>Receive buffer has data</p>")
        .def("read", &status_t::rx_ready_field::read, "Read field value")
        .def("write", &status_t::rx_ready_field::write, "Write field value");
    // Field class: status.error
    py::class_<status_t::error_field, FieldBase>(m, "status_error_field", "<p>Error flag</p>")
        .def("read", &status_t::error_field::read, "Read field value")
        .def("write", &status_t::error_field::write, "Write field value");
    // Register class: data
    py::class_<data_t, RegisterBase>(m, "data_t", "<p>UART data buffer</p>")
        .def(py::init<uint64_t>())
        .def_readonly("data", &data_t::data)
        ;
    
    // Field class: data.data
    py::class_<data_t::data_field, FieldBase>(m, "data_data_field")
        .def("read", &data_t::data_field::read, "Read field value")
        .def("write", &data_t::data_field::write, "Write field value");
    // Register class: direction
    py::class_<direction_t, RegisterBase>(m, "direction_t", "<p>GPIO pin direction (0=input, 1=output)</p>")
        .def(py::init<uint64_t>())
        .def_readonly("direction", &direction_t::direction)
        ;
    
    // Field class: direction.direction
    py::class_<direction_t::direction_field, FieldBase>(m, "direction_direction_field")
        .def("read", &direction_t::direction_field::read, "Read field value")
        .def("write", &direction_t::direction_field::write, "Write field value");
    // Register class: output
    py::class_<output_t, RegisterBase>(m, "output_t", "<p>GPIO output values</p>")
        .def(py::init<uint64_t>())
        .def_readonly("output", &output_t::output)
        ;
    
    // Field class: output.output
    py::class_<output_t::output_field, FieldBase>(m, "output_output_field")
        .def("read", &output_t::output_field::read, "Read field value")
        .def("write", &output_t::output_field::write, "Write field value");
    // Register class: input
    py::class_<input_t, RegisterBase>(m, "input_t", "<p>GPIO input values</p>")
        .def(py::init<uint64_t>())
        .def_readonly("input", &input_t::input)
        ;
    
    // Field class: input.input
    py::class_<input_t::input_field, FieldBase>(m, "input_input_field")
        .def("read", &input_t::input_field::read, "Read field value")
        .def("write", &input_t::input_field::write, "Write field value");
    
    // Top-level SoC class
    py::class_<example_soc_t, NodeBase>(m, "example_soc_t")
        .def(py::init<>())
        .def("attach_master", &example_soc_t::attach_master, "Attach a master interface")
        .def_readonly("uart", &example_soc_t::uart)
        .def_readonly("gpio", &example_soc_t::gpio)
        ;
}