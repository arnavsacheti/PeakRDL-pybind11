/*
 * example_soc_descriptors.hpp
 * Generated by PeakRDL-pybind11
 * 
 * C++ descriptor classes for SystemRDL register map
 */

#ifndef EXAMPLE_SOC_DESCRIPTORS_HPP
#define EXAMPLE_SOC_DESCRIPTORS_HPP

#include <cstdint>
#include <string>
#include <memory>
#include <functional>

namespace example_soc {

// Forward declarations
class Master;
class RegisterBase;
class FieldBase;

/**
 * Abstract Master interface for register access
 */
class Master {
public:
    virtual ~Master() = default;
    
    /**
     * Read a value from the given address
     */
    virtual uint64_t read(uint64_t address, size_t width) = 0;
    
    /**
     * Write a value to the given address
     */
    virtual void write(uint64_t address, uint64_t value, size_t width) = 0;
};

/**
 * Base class for register fields
 */
class FieldBase {
public:
    FieldBase(const std::string& name, uint64_t offset, 
              uint8_t lsb, uint8_t width, bool readable, bool writable)
        : name_(name), offset_(offset), lsb_(lsb), 
          width_(width), readable_(readable), writable_(writable) {}
    
    virtual ~FieldBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    uint8_t lsb() const { return lsb_; }
    uint8_t msb() const { return lsb_ + width_ - 1; }
    uint8_t width() const { return width_; }
    bool is_readable() const { return readable_; }
    bool is_writable() const { return writable_; }
    
    uint64_t mask() const { 
        return ((1ULL << width_) - 1) << lsb_; 
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    uint8_t lsb_;
    uint8_t width_;
    bool readable_;
    bool writable_;
};

/**
 * Base class for registers
 */
class RegisterBase {
public:
    RegisterBase(const std::string& name, uint64_t offset, size_t width)
        : name_(name), offset_(offset), width_(width), master_(nullptr) {}
    
    virtual ~RegisterBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    size_t width() const { return width_; }
    
    void set_master(Master* master) { master_ = master; }
    
    /**
     * Read the full register value
     */
    uint64_t read() {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        return master_->read(offset_, width_);
    }
    
    /**
     * Write the full register value
     */
    void write(uint64_t value) {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        master_->write(offset_, value, width_);
    }
    
    /**
     * Read-modify-write operation with mask
     */
    void modify(uint64_t value, uint64_t mask) {
        uint64_t current = read();
        uint64_t new_value = (current & ~mask) | (value & mask);
        write(new_value);
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    size_t width_;
    Master* master_;
};

/**
 * Base class for address maps and register files
 */
class NodeBase {
public:
    NodeBase(const std::string& name, uint64_t offset)
        : name_(name), offset_(offset), master_(nullptr) {}
    
    virtual ~NodeBase() = default;
    
    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    
    virtual void set_master(Master* master) { 
        master_ = master;
    }
    
protected:
    std::string name_;
    uint64_t offset_;
    Master* master_;
};

// Forward declaration for example_soc
class example_soc_t;

// Forward declaration for uart
class uart_t;
// Forward declaration for gpio
class gpio_t;

// Register: control
class control_t : public RegisterBase {
public:
    control_t(uint64_t base_offset) 
        : RegisterBase("control", base_offset + 0x1000, 4) {}
    
    // Field: enable
    class enable_field : public FieldBase {
    public:
        enable_field(control_t* parent)
            : FieldBase("enable", parent->offset(), 
                       0, 1,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field enable is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field enable is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        control_t* parent_;
    };
    
    enable_field enable{this};
    // Field: baudrate
    class baudrate_field : public FieldBase {
    public:
        baudrate_field(control_t* parent)
            : FieldBase("baudrate", parent->offset(), 
                       1, 3,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field baudrate is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field baudrate is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        control_t* parent_;
    };
    
    baudrate_field baudrate{this};
    // Field: parity
    class parity_field : public FieldBase {
    public:
        parity_field(control_t* parent)
            : FieldBase("parity", parent->offset(), 
                       4, 2,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field parity is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field parity is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        control_t* parent_;
    };
    
    parity_field parity{this};
};

// Register: status
class status_t : public RegisterBase {
public:
    status_t(uint64_t base_offset) 
        : RegisterBase("status", base_offset + 0x1004, 4) {}
    
    // Field: tx_ready
    class tx_ready_field : public FieldBase {
    public:
        tx_ready_field(status_t* parent)
            : FieldBase("tx_ready", parent->offset(), 
                       0, 1,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field tx_ready is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field tx_ready is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        status_t* parent_;
    };
    
    tx_ready_field tx_ready{this};
    // Field: rx_ready
    class rx_ready_field : public FieldBase {
    public:
        rx_ready_field(status_t* parent)
            : FieldBase("rx_ready", parent->offset(), 
                       1, 1,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field rx_ready is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field rx_ready is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        status_t* parent_;
    };
    
    rx_ready_field rx_ready{this};
    // Field: error
    class error_field : public FieldBase {
    public:
        error_field(status_t* parent)
            : FieldBase("error", parent->offset(), 
                       2, 1,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field error is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field error is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        status_t* parent_;
    };
    
    error_field error{this};
};

// Register: data
class data_t : public RegisterBase {
public:
    data_t(uint64_t base_offset) 
        : RegisterBase("data", base_offset + 0x1008, 4) {}
    
    // Field: data
    class data_field : public FieldBase {
    public:
        data_field(data_t* parent)
            : FieldBase("data", parent->offset(), 
                       0, 8,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field data is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field data is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        data_t* parent_;
    };
    
    data_field data{this};
};

// Register: direction
class direction_t : public RegisterBase {
public:
    direction_t(uint64_t base_offset) 
        : RegisterBase("direction", base_offset + 0x2000, 4) {}
    
    // Field: direction
    class direction_field : public FieldBase {
    public:
        direction_field(direction_t* parent)
            : FieldBase("direction", parent->offset(), 
                       0, 16,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field direction is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field direction is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        direction_t* parent_;
    };
    
    direction_field direction{this};
};

// Register: output
class output_t : public RegisterBase {
public:
    output_t(uint64_t base_offset) 
        : RegisterBase("output", base_offset + 0x2004, 4) {}
    
    // Field: output
    class output_field : public FieldBase {
    public:
        output_field(output_t* parent)
            : FieldBase("output", parent->offset(), 
                       0, 16,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field output is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field output is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        output_t* parent_;
    };
    
    output_field output{this};
};

// Register: input
class input_t : public RegisterBase {
public:
    input_t(uint64_t base_offset) 
        : RegisterBase("input", base_offset + 0x2008, 4) {}
    
    // Field: input
    class input_field : public FieldBase {
    public:
        input_field(input_t* parent)
            : FieldBase("input", parent->offset(), 
                       0, 16,
                       true,
                       true),
              parent_(parent) {}
        
        uint64_t read() {
            if (!is_readable()) {
                throw std::runtime_error("Field input is not readable");
            }
            uint64_t reg_val = parent_->read();
            return (reg_val & mask()) >> lsb_;
        }
        
        void write(uint64_t value) {
            if (!is_writable()) {
                throw std::runtime_error("Field input is not writable");
            }
            uint64_t field_val = (value << lsb_) & mask();
            parent_->modify(field_val, mask());
        }
        
    private:
        input_t* parent_;
    };
    
    input_field input{this};
};


// Top-level SoC class
class example_soc_t : public NodeBase {
public:
    example_soc_t() : NodeBase("example_soc", 0) {
        uart.set_offset(offset_);
        gpio.set_offset(offset_);
    }
    
    void attach_master(Master* master) {
        set_master(master);
        propagate_master(master);
    }
    
    void set_offset(uint64_t offset) {
        offset_ = offset;
        uart.set_offset(offset_);
        gpio.set_offset(offset_);
    }
    
    void propagate_master(Master* master) {
        uart.set_master(master);
        gpio.set_master(master);
    }
    
    uart_t uart{0x1000};
    gpio_t gpio{0x2000};
};

} // namespace example_soc

#endif // EXAMPLE_SOC_DESCRIPTORS_HPP