/**
 * Abstract Master interface for register access
 */
class Master {
public:
    virtual ~Master() = default;

    /**
     * Read a value from the given address
     */
    virtual uint64_t read(uint64_t address, size_t width) = 0;

    /**
     * Write a value to the given address
     */
    virtual void write(uint64_t address, uint64_t value, size_t width) = 0;

    /**
     * String representation
     */
    virtual std::string __repr__() const {
        return "<Master>";
    }
};

/**
 * Base class for register fields
 */
class FieldBase {
public:
    FieldBase(const std::string& name, uint64_t offset,
              uint8_t lsb, uint8_t width, bool readable, bool writable)
        : name_(name), offset_(offset), lsb_(lsb),
          width_(width), readable_(readable), writable_(writable) {}

    virtual ~FieldBase() = default;

    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    uint8_t lsb() const { return lsb_; }
    uint8_t msb() const { return lsb_ + width_ - 1; }
    uint8_t width() const { return width_; }
    bool is_readable() const { return readable_; }
    bool is_writable() const { return writable_; }

    uint64_t mask() const {
        return ((1ULL << width_) - 1) << lsb_;
    }

    /**
     * String representation
     */
    std::string __repr__() const {
        std::ostringstream oss;
        oss << "<Field '" << name_ << "' @ 0x" << std::hex << offset_
            << " [" << std::dec << static_cast<int>(msb()) << ":" << static_cast<int>(lsb()) << "]"
            << (readable_ ? " R" : "") << (writable_ ? "W" : "") << ">";
        return oss.str();
    }

protected:
    std::string name_;
    uint64_t offset_;
    uint8_t lsb_;
    uint8_t width_;
    bool readable_;
    bool writable_;
};

/**
 * Base class for registers
 */
class RegisterBase {
public:
    RegisterBase(const std::string& name, uint64_t offset, size_t width)
        : name_(name), offset_(offset), width_(width), master_(nullptr),
          in_context_(false), cached_value_(0) {}

    virtual ~RegisterBase() = default;

    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }
    size_t width() const { return width_; }

    void set_master(Master* master) { master_ = master; }

    /**
     * Read the full register value
     */
    uint64_t read() {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        // If in context, return cached value
        if (in_context_) {
            return cached_value_;
        }
        return master_->read(offset_, width_);
    }

    /**
     * Write the full register value
     */
    void write(uint64_t value) {
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        // If in context, update cached value
        if (in_context_) {
            cached_value_ = value;
        } else {
            master_->write(offset_, value, width_);
        }
    }

    /**
     * Read-modify-write operation with mask
     */
    void modify(uint64_t value, uint64_t mask) {
        uint64_t current = read();
        uint64_t new_value = (current & ~mask) | (value & mask);
        write(new_value);
    }

    /**
     * Enter context manager - read current value and cache it
     */
    RegisterBase* __enter__() {
        if (in_context_) {
            throw std::runtime_error("Register " + name_ + " is already in a context");
        }
        if (!master_) {
            throw std::runtime_error("No master attached to register: " + name_);
        }
        // Read current value and cache it
        cached_value_ = master_->read(offset_, width_);
        in_context_ = true;
        return this;
    }

    /**
     * Exit context manager - write cached value back to register
     */
    void exit_context() {
        if (!in_context_) {
            throw std::runtime_error("Register " + name_ + " is not in a context");
        }
        // Write cached value back to register
        if (master_) {
            master_->write(offset_, cached_value_, width_);
        }
        in_context_ = false;
    }

    /**
     * String representation
     */
    std::string __repr__() const {
        std::ostringstream oss;
        oss << "<Register '" << name_ << "' @ 0x" << std::hex << std::setfill('0')
            << std::setw(4) << offset_ << " (" << std::dec << width_ << " bits)>";
        return oss.str();
    }

protected:
    std::string name_;
    uint64_t offset_;
    size_t width_;
    Master* master_;
    bool in_context_;
    uint64_t cached_value_;
};

/**
 * Base class for address maps and register files
 */
class NodeBase {
public:
    NodeBase(const std::string& name, uint64_t offset)
        : name_(name), offset_(offset), master_(nullptr) {}

    virtual ~NodeBase() = default;

    const std::string& name() const { return name_; }
    uint64_t offset() const { return offset_; }

    virtual void set_master(Master* master) {
        master_ = master;
    }

    /**
     * String representation
     */
    virtual std::string __repr__() const {
        std::ostringstream oss;
        oss << "<Node '" << name_ << "' @ 0x" << std::hex << std::setfill('0')
            << std::setw(4) << offset_ << ">";
        return oss.str();
    }

protected:
    std::string name_;
    uint64_t offset_;
    Master* master_;
};

/**
 * Base class for memory arrays
 * Provides list-like interface for accessing memory entries
 */
template<typename EntryType>
class MemoryBase : public NodeBase {
public:
    MemoryBase(const std::string& name, uint64_t base_offset, size_t num_entries, size_t entry_size)
        : NodeBase(name, base_offset), num_entries_(num_entries), entry_size_(entry_size) {
        // Pre-allocate all entries
        entries_.reserve(num_entries);
        for (size_t i = 0; i < num_entries; ++i) {
            entries_.emplace_back(base_offset + i * entry_size);
        }
    }

    virtual ~MemoryBase() = default;

    void set_master(Master* master) override {
        NodeBase::set_master(master);
        for (auto& entry : entries_) {
            entry.set_master(master);
        }
    }

    /**
     * Get entry at specific index
     */
    EntryType& operator[](size_t index) {
        if (index >= num_entries_) {
            throw std::out_of_range("Memory index out of range: " + std::to_string(index));
        }
        return entries_[index];
    }

    const EntryType& operator[](size_t index) const {
        if (index >= num_entries_) {
            throw std::out_of_range("Memory index out of range: " + std::to_string(index));
        }
        return entries_[index];
    }

    /**
     * Get number of entries
     */
    size_t size() const { return num_entries_; }

    /**
     * Iterator support
     */
    typename std::vector<EntryType>::iterator begin() { return entries_.begin(); }
    typename std::vector<EntryType>::iterator end() { return entries_.end(); }
    typename std::vector<EntryType>::const_iterator begin() const { return entries_.begin(); }
    typename std::vector<EntryType>::const_iterator end() const { return entries_.end(); }

    /**
     * String representation
     */
    std::string __repr__() const override {
        std::ostringstream oss;
        oss << "<Memory '" << name_ << "' @ 0x" << std::hex << std::setfill('0')
            << std::setw(4) << offset_ << " [" << std::dec << num_entries_ << " entries]>";
        return oss.str();
    }

protected:
    std::vector<EntryType> entries_;
    size_t num_entries_;
    size_t entry_size_;
};
