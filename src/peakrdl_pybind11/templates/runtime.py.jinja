"""
{{ soc_name }} - Generated SoC register map
Generated by PeakRDL-pybind11 from SystemRDL

This module provides Python access to the {{ soc_name }} register map.
"""

try:
    from ._{{ soc_name }}_native import *
except ImportError as e:
    import sys
    print(f"Error importing native module: {e}", file=sys.stderr)
    print("You need to build the C++ extension first:", file=sys.stderr)
    print(f"  cd <output_dir> && python setup.py build_ext --inplace", file=sys.stderr)
    raise

from peakrdl_pybind11.int_types import RegisterInt, FieldInt, RegisterIntFlag, RegisterIntEnum

__all__ = ['{{ soc_name }}_t', 'Master', 'create', 'RegisterInt', 'FieldInt', 'RegisterIntFlag', 'RegisterIntEnum']

def create():
    """
    Create a new instance of the {{ soc_name }} register map
    
    Returns:
        {{ soc_name }}_t: A new SoC instance
    
    Example:
        >>> soc = create()
        >>> from peakrdl_pybind11.masters import MockMaster
        >>> # Wrap the MockMaster to work with this SoC
        >>> mock = MockMaster()
        >>> 
        >>> class WrappedMaster(Master):
        >>>     def read(self, addr, width):
        >>>         return mock.read(addr, width)
        >>>     def write(self, addr, val, width):
        >>>         mock.write(addr, val, width)
        >>> 
        >>> soc.attach_master(WrappedMaster())
    """
    return {{ soc_name }}_t()

def wrap_master(master_impl):
    """
    Wrap a Python master implementation to work with this SoC
    
    Args:
        master_impl: A master object with read(addr, width) and write(addr, val, width) methods
    
    Returns:
        Master: A wrapped master that can be attached to the SoC
    
    Example:
        >>> from peakrdl_pybind11.masters import MockMaster
        >>> soc = create()
        >>> master = wrap_master(MockMaster())
        >>> soc.attach_master(master)
    """
    class WrappedMaster(Master):
        def __init__(self):
            Master.__init__(self)
            self.impl = master_impl
            
        def read(self, addr, width):
            return self.impl.read(addr, width)
            
        def write(self, addr, val, width):
            self.impl.write(addr, val, width)
    
    return WrappedMaster()

__all__.append('wrap_master')

# Add enhanced read/write methods that use RegisterInt/FieldInt
# These will be mixed in after the module is loaded

# Map of register class names to their flag/enum types
_special_register_types = {}
{% for reg in nodes.flag_regs %}
_special_register_types['{{ reg.inst_name }}_t'] = ('flag', '{{ reg.inst_name }}_Flags')
{% endfor %}
{% for reg in nodes.enum_regs %}
_special_register_types['{{ reg.inst_name }}_t'] = ('enum', '{{ reg.inst_name }}_Enum')
{% endfor %}

def _make_enhanced_register_read(reg_class):
    """Create enhanced read method for a register class."""
    original_read = reg_class.read
    
    def enhanced_read(self):
        value = original_read(self)
        
        # Check if this is a special register type (flag or enum)
        class_name = self.__class__.__name__
        if class_name in _special_register_types:
            special_type, special_class_name = _special_register_types[class_name]
            special_class = globals()[special_class_name]
            # Return the appropriate enum/flag value
            # Try to find a matching member, or return the raw value
            try:
                return special_class(value)
            except ValueError:
                # If the value doesn't match any member, return raw int
                return value
        
        # Build fields dictionary from field attributes
        fields = {}
        for attr_name in dir(self):
            if not attr_name.startswith('_') and attr_name not in [
                'name', 'offset', 'width', 'read', 'write', 'modify', 
                'set_master', 'is_readable', 'is_writable'
            ]:
                try:
                    attr = getattr(self, attr_name)
                    if hasattr(attr, 'lsb') and hasattr(attr, 'width'):
                        fields[attr_name] = (attr.lsb, attr.width)
                except:
                    pass
        
        return RegisterInt(value, self.offset, self.width, fields)
    
    return enhanced_read


def _make_enhanced_register_write(reg_class):
    """Create enhanced write method for a register class."""
    original_write = reg_class.write
    original_modify = reg_class.modify
    
    def enhanced_write(self, value):
        if isinstance(value, FieldInt):
            # Read-modify-write for FieldInt
            # Extract the field value and position from FieldInt
            field_value = int(value)
            mask = value.mask
            # Shift the field value to the correct position
            shifted_value = (field_value << value.lsb) & mask
            original_modify(self, shifted_value, mask)
        else:
            # Direct write for int or RegisterInt
            original_write(self, int(value))
    
    return enhanced_write


def _make_enhanced_field_read(field_class):
    """Create enhanced read method for a field class."""
    original_read = field_class.read
    
    def enhanced_read(self):
        value = original_read(self)
        return FieldInt(value, self.lsb, self.width, self.offset)
    
    return enhanced_read


def _make_enhanced_field_write(field_class):
    """Create enhanced write method for a field class."""
    original_write = field_class.write
    
    def enhanced_write(self, value):
        # Accept both int and FieldInt
        original_write(self, int(value))
    
    return enhanced_write


# Enhance all generated register and field classes
# We need to do this after all classes are defined
_register_types = []
_field_types = []

# Collect register types (classes ending in _t with read/write/offset/width)
for _name in list(globals().keys()):
    _obj = globals()[_name]
    if isinstance(_obj, type):
        if _name.endswith('_t') and hasattr(_obj, 'read') and hasattr(_obj, 'write'):
            if hasattr(_obj, 'offset') and hasattr(_obj, 'width') and hasattr(_obj, 'modify'):
                _register_types.append(_obj)
        elif '_field' in _name and hasattr(_obj, 'read') and hasattr(_obj, 'write'):
            if hasattr(_obj, 'lsb') and hasattr(_obj, 'width'):
                _field_types.append(_obj)

# Apply enhancements
for _reg_type in _register_types:
    _reg_type.read = _make_enhanced_register_read(_reg_type)
    _reg_type.write = _make_enhanced_register_write(_reg_type)

for _field_type in _field_types:
    _field_type.read = _make_enhanced_field_read(_field_type)
    _field_type.write = _make_enhanced_field_write(_field_type)

# Generate IntFlag classes for registers with flag UDP property
{% for reg in nodes.flag_regs %}
# Create IntFlag for {{ reg.inst_name }}
{{ reg.inst_name }}_Flags = RegisterIntFlag('{{ reg.inst_name }}_Flags', {
    {% for field in reg.fields() %}
    '{{ field.inst_name.upper() }}': {% if field.width == 1 %}{{ 2 ** field.lsb }}{% else %}{{ (2 ** field.width - 1) * (2 ** field.lsb) }}{% endif %},
    {% endfor %}
})
{{ reg.inst_name }}_Flags._offset = {{ reg.absolute_address }}  # type: ignore[attr-defined]
{{ reg.inst_name }}_Flags._width = {{ (reg.size + 7) // 8 }}  # type: ignore[attr-defined]
__all__.append('{{ reg.inst_name }}_Flags')

{% endfor %}

# Generate IntEnum classes for registers with enum UDP property
{% for reg in nodes.enum_regs %}
# Create IntEnum for {{ reg.inst_name }}
{{ reg.inst_name }}_Enum = RegisterIntEnum('{{ reg.inst_name }}_Enum', {
    {% for field in reg.fields() %}
    '{{ field.inst_name.upper() }}': {{ 2 ** field.lsb }},
    {% endfor %}
})
{{ reg.inst_name }}_Enum._offset = {{ reg.absolute_address }}  # type: ignore[attr-defined]
{{ reg.inst_name }}_Enum._width = {{ (reg.size + 7) // 8 }}  # type: ignore[attr-defined]
__all__.append('{{ reg.inst_name }}_Enum')

{% endfor %}

# Clean up temporary variables
del _register_types, _field_types, _name, _obj
if '_reg_type' in dir():
    del _reg_type
if '_field_type' in dir():
    del _field_type


